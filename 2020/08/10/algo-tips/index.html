<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="ReZero"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="https://rezeros.github.io/2020/08/10/algo-tips/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Before that, think more."><meta property="og:type" content="article"><meta property="og:title" content="Algo tips"><meta property="og:url" content="https://rezeros.github.io/2020/08/10/algo-tips/index.html"><meta property="og:site_name" content="ReZero"><meta property="og:description" content="Before that, think more."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://rezeros.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2020-08-10T10:35:00.000Z"><meta property="article:modified_time" content="2025-04-15T23:03:26.456Z"><meta property="article:author" content="ReZero"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="Math"><meta property="article:tag" content="Tips"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://rezeros.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/redefine-favicon.svg"><title>Algo tips | ReZero&#39;s blog</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/build/tailwind.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><script src="/js/build/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"rezeros.github.io",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:"Advance ruthlessly—whatever the cost!"},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Before that, think more."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"Before that, think more.",subtitle:{text:[],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Categories:{path:"/categories/",icon:"fa-solid fa-folder"},Tags:{path:"/tags/",icon:"fa-solid fa-tags"}},search:{enable:!1,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:null},article_date_format:"auto",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/8/17 11:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">Advance ruthlessly—whatever the cost!</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">ReZero&#39;s blog</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/categories/"><i class="fa-solid fa-folder fa-fw"></i> CATEGORIES</a></li><li class="navbar-item"><a href="/tags/"><i class="fa-solid fa-tags fa-fw"></i> TAGS</a></li></ul></div><div class="mobile"><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/"><span>CATEGORIES </span><i class="fa-solid fa-folder fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/tags/"><span>TAGS </span><i class="fa-solid fa-tags fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">138</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">21</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">60</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Algo tips</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/redefine-avatar.svg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">ReZero</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv4</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2020-08-10 10:35</span> <span class="mobile">2020-08-10 10:35</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-04-15 23:03:26</span> <span class="mobile">2025-04-15 23:03:26</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/Algorithm/">Algorithm</a>&nbsp;</li><li>| <a href="/tags/Math/">Math</a>&nbsp;</li><li>| <a href="/tags/Tips/">Tips</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 注意 </span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; </span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) </span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 注意 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意 &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol><li>为什么 while 循环的条件中是 &lt;&#x3D;，⽽不是 &lt;</li></ol><ul><li>因为初始化 right 的赋值是 nums.length - 1 ，即最后一个元素的索引，而不是nums.length</li><li>防止漏掉 <code>[a, a]</code> 区间</li></ul><h2 id="RSA-basic"><a href="#RSA-basic" class="headerlink" title="RSA-basic"></a>RSA-basic</h2><blockquote><p>费马小定理(Fermat Theory)是数论中的一个重要定理，其内容为： 假如p是质数，且gcd(a,p)&#x3D;1，那么<br>a(p-1)≡1（mod<br>p）。即：假如a是整数，p是质数，且a,p互质(即两者只有一个公约数1)，那么a的(p-1)次方除以p的余数恒等于1。</p></blockquote><hr><p>蒙哥马利幂模运算<br>RSA算法的核心之一</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">pows</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> mod)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>)&#123;</span><br><span class="line">            temp = temp*a%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a*a%mod;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ol><li>找到所有入度为0的点插进队列</li><li>选择一个并输出它<ul><li>然后删掉与之关联的所有边（即任何与之相连的入度-1）</li><li>删除过程遇到入度为0点插入队列</li></ul></li><li>重复第二步，直到队列中无0点</li></ol><hr><h4 id="优化：如果要求最小字典序"><a href="#优化：如果要求最小字典序" class="headerlink" title="优化：如果要求最小字典序"></a>优化：如果要求最小字典序</h4><blockquote><p><strong>用反向拓扑加优先队列</strong></p></blockquote><pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; G[5020];
map&lt;string, int&gt; maps;
map&lt;int, string&gt; mapr;

struct less_cmp&#123;
    bool operator()(const int &amp;a, const int &amp;b)&#123;
        return mapr[a] &gt; mapr[b];
    &#125;
&#125;;

int main()&#123;
    int T;
    cin &gt;&gt; T;
    for(int kase = 1; kase &lt;= T; ++kase)&#123;
        int n, m, in[5020], cnt = 0, ans[5020];
        cin &gt;&gt; n;
        for(int i = 0; i &lt; n; ++i)&#123;
            string cla;
            cin &gt;&gt; cla;
            maps.insert(pair&lt;string, int&gt;(cla, i));
            mapr.insert(pair&lt;int, string&gt;(i, cla));
        &#125;
        cin &gt;&gt; m;
        for(int i = 0; i &lt; m; ++i)&#123;
            string as, bs;
            cin &gt;&gt; as &gt;&gt; bs;
            int u = maps[as], v = maps[bs];
            G[u].push_back(v);
            in[v]++;
        &#125;
        priority_queue&lt;int, vector&lt;int&gt;, less_cmp &gt; que;
        for(int i = 0; i &lt; n; ++i)&#123;
            if(in[i] == 0)
                que.push(i);
        &#125;
        vector&lt;int&gt;::iterator iter;
        while(!que.empty())&#123;
            int temp = que.top();
            que.pop();
            ans[cnt++] = temp;
            for(iter = G[temp].begin(); iter != G[temp].end(); ++iter)&#123;
                    if(--in[*iter] == 0)&#123;
                        que.push(*iter);
                    &#125;
                &#125;
        &#125;
        cout &lt;&lt; &quot;Case &quot; &lt;&lt; kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;
        for(int i = 0; i &lt; cnt; ++i)&#123;
            cout &lt;&lt; mapr[ans[i]] &lt;&lt; endl;
        &#125;
        maps.clear();
        mapr.clear();
        for(int i = 0; i &lt; 5020; ++i)&#123;
            G[i].clear();
        &#125;
    &#125;
&#125;
</code></pre><p>开心的wrong answer-_-</p><blockquote><p>第一行为样例组数T。每组样例第一行为课程数量n（1 &lt;&#x3D; n &lt;&#x3D; 5000)，以下n行每行表示一门课程名称。接下来为关系数量m（1 &lt;&#x3D; m &lt;&#x3D; 10000)，每一行有两个课程名称a、b，表示a课程要开设在b课程前面。（输入保证无环）</p></blockquote><h4 id="原题如上，旭哥思路的代码"><a href="#原题如上，旭哥思路的代码" class="headerlink" title="原题如上，旭哥思路的代码"></a>原题如上，旭哥思路的代码</h4><pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;
vector&lt;int&gt; G[5020];
string mapr[5020];
map&lt;string, int&gt; maps;

int main()&#123;
    int T;  scanf(&quot;%d&quot;, &amp;T);
    for(int kase = 1; kase &lt;= T; ++kase)&#123;
        int n, m, in[5020] = &#123;0&#125;, cnt = 0, ans[5020];

        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 0; i &lt; n; ++i) G[i].clear();
        maps.clear();
        for(int i = 0; i &lt; n; ++i)&#123;
            char as[44];
            scanf(&quot;%s&quot;, as);
            mapr[i] = as;
        &#125;
        sort(mapr, mapr + n);
        for(int i = 0; i &lt; n; ++i)&#123;
            maps[mapr[i]] = i;
        &#125;

        scanf(&quot;%d&quot;, &amp;m);
        for(int i = 0; i &lt; m; ++i)&#123;
            char as[44], bs[44];
            scanf(&quot;%s %s&quot;, as, bs);
            int u = maps[as], v = maps[bs];
            G[u].push_back(v);
            ++in[v];
        &#125;

        printf(&quot;Case %d:\n&quot;, kase);
        for(int i = 0; i &lt; n; ++i)&#123;
            int temp = 0;
            for(int j = 0; j &lt; n; ++j)&#123;
                if(!in[j])&#123;
                    printf(&quot;%s\n&quot;, mapr[j].c_str());
                    temp = j; --in[j];
                    break;
                &#125;
            &#125;
            for(int k = 0; k &lt; G[temp].size(); ++k)&#123;
                --in[G[temp][k]];
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><ul><li>权值置-1，排除节点</li><li>G（vector）来控制制约关系</li><li>sort排序保证字典序</li></ul><h2 id="并查集-（转）"><a href="#并查集-（转）" class="headerlink" title="并查集 （转）"></a>并查集 （转）</h2><blockquote><p>本文由 <a class="link" target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 转码， 原文地址 <a class="link" target="_blank" rel="noopener" href="http://blog.csdn.net/dellaserss/article/details/7724401">http://blog.csdn.net/dellaserss/article/details/7724401<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></blockquote><p>这个文章是几年前水 acm 的时候转的, 当时也不知道作者是谁, 要是有人知道的话说一下吧 并查集是我暑假从高手那里学到的一招，觉得真是太精妙的设计了。以前我无法解决的一类问题竟然可以用如此简单高效的方法搞定。不分享出来真是对不起 party 了。（party：我靠，关我嘛事啊？我跟你很熟么？） 来看一个实例，<a class="link" target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1232">杭电 1232 畅通工程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。如果是 1 个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是 2 个连通分支，则只要再修 1 条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是 3 个连通分支，则只要再修两条路…… 以下面这组数据输入数据来说明 4 2 1 3 4 3 第一行告诉你，一共有 4 个点，2 条路。下面两行告诉你，1、3 之间有条路，4、3 之间有条路。那么整幅图就被分成了 1-3-4 和 2 两部分。只要再加一条路，把 2 和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是 1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。 这可如何是好？ 我以前也不会呀，自从用了并查集之后，嗨，效果还真好！我们全家都用它！ 并查集由一个整数型的数组和两个函数构成。数组 pre[] 记录了每个点的前导点是什么，函数 find 是查找，join 是合并。</p><pre><code>int pre[1000];

int find(int x)               // 查找根节点
&#123;   
    int r = x;
    while(pre[r] != r)         //返回根节点 r
    r = pre[r];
    int i = x ,j;
    while(i != r)                // 路径压缩 
    &#123;     
        j = pre[i]; // 在改变上级之前用临时变量  j 记录下他的值     
        pre[i] = r ; // 把上级改为根节点
        i = j; 
    &#125;   
    return r;
&#125;

void join(int x,int y)     // 判断 x y 是否连通，
 // 如果已经连通，就不用管了 // 如果不连通，就把它们所在的连通分支合并起,
&#123;
    int fx = find(x),fy = find(y);
    if(fx != fy)
        pre[fx]=fy;
&#125;
</code></pre><p>为了解释并查集的原理，我将举一个更有爱的例子。 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉 “朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名 “齐达内朋友之队”“罗纳尔多朋友之队”…… 两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？” 这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。 <img lazyload src="/images/loading.svg" data-src="http://hi.csdn.net/attachment/201107/29/0_1311901712oy9f.gif"> 下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从 1 或者 0 开始编号（依据题意而定），pre[15]&#x3D;3 就表示 15 号大侠的上级是 3 号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 find 这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。</p><pre><code>int find(int x)      // 查找我（x）的掌门
&#123;
    int r = x;                   // 委托 r 去找掌门
    while(pre[r] != r)  // 如果 r 的上级不是 r 自己（也就是说找到的大侠他不是掌门 = =）
        r = pre[r];               // r 就接着找他的上级，直到找到掌门为止。
    return r;              // 掌门驾到~~~

&#125;
</code></pre><p>再来看&#96;&#96;看 join 函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个 pre[] 数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若 MM 是我非常喜欢的两个人物，他们的终极 boss 分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。” 他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极 boss 都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。” 玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！” 抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？</p><pre><code>void join(int x, int  y)      // 我想让虚竹和周芷若做朋友
&#123;
    int fx=find(x),fy=find(y);      //虚竹的老大是玄慈，芷若 MM 的老大是灭绝
    if(fx!=fy)                        // 玄慈和灭绝显然不是同一个人_**
    pre[fx]=fy;               // 方丈只好委委屈屈地当了师太的手下啦_**
&#125;
</code></pre><p>再来看看路径压缩算法。建立门派的过程是用 join 函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终 boss 都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！” 我叫住他俩。 “哦，对了，还要做路径压缩。” 两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长…… 仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。 <img lazyload src="/images/loading.svg" data-src="http://hi.csdn.net/attachment/201107/29/0_131190167189S8.gif"><a class="link" target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1232">hdu1232<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><pre><code>#include&lt;iostream&gt;  
using namespace std;
  

int  pre[1050];
  
bool t[1050];  //t 用于标记独立块的根结点  

int Find(int x)  
&#123;
      
    int r = x;
      
    while(r != pre[r])  
        r = pre[r];

    int i = x,j;
      
    while(pre[i] != r)  
    &#123;
        j = pre[i];
        pre[i] = r;
        i = j;
    &#125;  
    return r;
&#125;  

void mix(int x,int y)  
&#123;
      
    int fx = Find(x), fy = Find(y);
      
    if(fx != fy)  
    &#123;  
        pre[fy] = fx;
    &#125;  
&#125;   

int main()  
&#123;
    int N, M, a, b, i, j, ans;

    while(scanf(&quot;%d %d&quot;, &amp;N, &amp;M) &amp;&amp; N)  
    &#123;
        for(i = 1; i &lt;= N; ++i)           // 初始化   
            pre[i] = i;
        for(i = 1; i &lt;= M; ++i)           // 吸收并整理数据   
        &#123;
            scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
            mix(a, b);
        &#125;
        memset(t, 0, sizeof(t));
        for(i = 1; i &lt;= N; ++i)           // 标记根结点  
        &#123;
            t[Find(i)] = 1;      
        &#125;  
        for(ans = 0, i = 1; i &lt;= N; ++i)  
            if(t[i])  
                ans++;
        printf(&quot;%d\n&quot;, ans-1);
    &#125;  
    return 0;
&#125;//dellaserss  
</code></pre><p>以下为原文附的代码: 回到开头提出的问题，我的代码如下：</p><pre><code>int pre[1000];

int find(int x)
&#123;
    int r = x;

   while(pre[r] != r)
   r = pre[r];

   int i = x; int j;

   while(i != r)
   &#123;
        j = pre[i];
        pre[i] = r;
        i = j;
   &#125;
   return r;
&#125;

int main()
&#123;

   int n, m, p1, p2, i, total, f1, f2;

   while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)         // 读入 n，如果 n 为 0，结束
   &#123;   
        // 刚开始的时候，有 n 个城镇，一条路都没有 // 那么要修 n-1 条路才能把它们连起来
        total = n-1;  
        // 每个点互相独立，自成一个集合，从 1 编号到 n // 所以每个点的上级都是自己
        for(i = 1;i &lt;= n;i++) 
        &#123; 
            pre[i ]=i;
        &#125;
        // 共有 m 条路
        scanf(&quot;%d&quot;,&amp;m); while(m--)
        &#123; 
            // 下面这段代码，其实就是 join 函数，只是稍作改动以适应题目要求
            // 每读入一条路，看它的端点 p1，p2 是否已经在一个连通分支里了
            scanf(&quot;%d %d&quot;, &amp;p1, &amp;p2);
            f1 = find(p1);
            f2 = find(p2);

// 如果是不连通的，那么把这两个分支连起来
// 分支的总数就减少了 1，还需建的路也就减了 1
            if(f1 != f2)&#123;
                pre[f2] = f1;
                total--;
            &#125;
            // 如果两点已经连通了，那么这条路只是在图上增加了一个环 // 对连通性没有任何影响，无视掉
        &#125;
        // 最后输出还要修的路条数
        printf(&quot;%d\n&quot;,total);
    &#125;
    return 0;
&#125;
</code></pre><h2 id="Eight-queens"><a href="#Eight-queens" class="headerlink" title="Eight queens"></a>Eight queens</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> answer[<span class="number">92</span>]&#123;</span><br><span class="line"><span class="number">15863724</span>,<span class="number">16837425</span>,<span class="number">17468253</span>,<span class="number">17582463</span>,<span class="number">24683175</span>,<span class="number">25713864</span>,<span class="number">25741863</span>,<span class="number">26174835</span>,<span class="number">26831475</span>,</span><br><span class="line"><span class="number">27368514</span>,<span class="number">27581463</span>,<span class="number">28613574</span>,<span class="number">31758246</span>,<span class="number">35281746</span>,<span class="number">35286471</span>,<span class="number">35714286</span>,<span class="number">35841726</span>,<span class="number">36258174</span>,</span><br><span class="line"><span class="number">36271485</span>,<span class="number">36275184</span>,<span class="number">36418572</span>,<span class="number">36428571</span>,<span class="number">36814752</span>,<span class="number">36815724</span>,<span class="number">36824175</span>,<span class="number">37285146</span>,<span class="number">37286415</span>,</span><br><span class="line"><span class="number">38471625</span>,<span class="number">41582736</span>,<span class="number">41586372</span>,<span class="number">42586137</span>,<span class="number">42736815</span>,<span class="number">42736851</span>,<span class="number">42751863</span>,<span class="number">42857136</span>,<span class="number">42861357</span>,</span><br><span class="line"><span class="number">46152837</span>,<span class="number">46827135</span>,<span class="number">46831752</span>,<span class="number">47185263</span>,<span class="number">47382516</span>,<span class="number">47526138</span>,<span class="number">47531682</span>,<span class="number">48136275</span>,<span class="number">48157263</span>,</span><br><span class="line"><span class="number">48531726</span>,<span class="number">51468273</span>,<span class="number">51842736</span>,<span class="number">51863724</span>,<span class="number">52468317</span>,<span class="number">52473861</span>,<span class="number">52617483</span>,<span class="number">52814736</span>,<span class="number">53168247</span>,</span><br><span class="line"><span class="number">53172864</span>,<span class="number">53847162</span>,<span class="number">57138642</span>,<span class="number">57142863</span>,<span class="number">57248136</span>,<span class="number">57263148</span>,<span class="number">57263184</span>,<span class="number">57413862</span>,<span class="number">58413627</span>,</span><br><span class="line"><span class="number">58417263</span>,<span class="number">61528374</span>,<span class="number">62713584</span>,<span class="number">62714853</span>,<span class="number">63175824</span>,<span class="number">63184275</span>,<span class="number">63185247</span>,<span class="number">63571428</span>,<span class="number">63581427</span>,</span><br><span class="line"><span class="number">63724815</span>,<span class="number">63728514</span>,<span class="number">63741825</span>,<span class="number">64158273</span>,<span class="number">64285713</span>,<span class="number">64713528</span>,<span class="number">64718253</span>,<span class="number">68241753</span>,<span class="number">71386425</span>,</span><br><span class="line"><span class="number">72418536</span>,<span class="number">72631485</span>,<span class="number">73168524</span>,<span class="number">73825164</span>,<span class="number">74258136</span>,<span class="number">74286135</span>,<span class="number">75316824</span>,<span class="number">82417536</span>,<span class="number">82531746</span>,<span class="number">83162574</span>,<span class="number">84136275</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> cases;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cases;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kase = <span class="number">0</span>; kase &lt; cases; ++kase)&#123;</span><br><span class="line">        <span class="type">int</span> n;  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; answer[n<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int vis[3][20] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">//int R[8] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">//int tot = 0;</span></span><br><span class="line"><span class="comment">//int n = 8;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void seac(int cur)&#123;</span></span><br><span class="line"><span class="comment">//    if(cur == 8) &#123;</span></span><br><span class="line"><span class="comment">//        tot++;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt; &quot;&quot;;</span></span><br><span class="line"><span class="comment">//        for(int i = 0; i &lt; 8; ++i)&#123;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; R[i] + 1;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &quot;,&quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    else for(int i = 0; i &lt; 8; ++i)&#123;</span></span><br><span class="line"><span class="comment">//        if(!vis[0][i] &amp;&amp; !vis[1][cur+i] &amp;&amp; !vis[2][cur-i+8])&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            R[cur] = i;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            vis[0][i] = vis[1][cur+i] = vis[2][cur-i+8] = 1;</span></span><br><span class="line"><span class="comment">//            seac(cur + 1);</span></span><br><span class="line"><span class="comment">//            vis[0][i] = vis[1][cur+i] = vis[2][cur-i+8] = 0;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//memset(vis, 0, sizeof(vis));</span></span><br><span class="line"><span class="comment">//    memset(R, 0, sizeof(R));</span></span><br><span class="line"><span class="comment">//    seac(0);</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h2 id="此算法由Robert-W-Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications-of-the-ACM”上。同年Stephen-Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert-W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。"><a href="#此算法由Robert-W-Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications-of-the-ACM”上。同年Stephen-Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert-W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。" class="headerlink" title="此算法由Robert W. Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications of the ACM”上。同年Stephen Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。"></a>此算法由Robert W. Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications of the ACM”上。同年Stephen Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。</h2><p>作者：ahalei来源：51CTO博客|2014-03-26 09:04</p><p>收藏</p><p>分享</p><p><img lazyload src="/images/loading.svg" data-src="http://s1.51cto.com/wyfs02/M00/23/1C/wKioL1MyKrDSFjpKAABU4EmV3Qc641.jpg-wh_651x-s_35035338.jpg" alt="081028t67l8vd73686e68m.png"></p><p>暑假，小哼准备去一些城市旅游。有些城市之间有公路，有些城市之间则没有，如下图。为了节省经费以及方便计划旅程，小哼希望在出发之前知道任意两个城市之前的最短路程。</p><p><img lazyload src="/images/loading.svg" data-src="http://s7.51cto.com/wyfs02/M02/23/1B/wKiom1MyKtiQEf2iAAApFLfvlAE293.jpg" alt="081028xjgvimgz7882qdu7.png"></p><p>上图中有4个城市8条公路，公路上的数字表示这条公路的长短。请注意这些公路是单向的。我们现在需要求任意两个城市之间的最短路程，也就是求任意两个点之间的最短路径。这个问题这也被称为“多源最短路径”问题。</p><p>现在需要一个数据结构来存储图的信息，我们仍然可以用一个4*4的矩阵（二维数组e）来存储。比如1号城市到2号城市的路程为2，则设e[1][2]的值为2。2号城市无法到达4号城市，则设置e[2][4]的值为∞。另外此处约定一个城市自己是到自己的也是0，例如e[1][1]为0，具体如下。</p><p><img lazyload src="/images/loading.svg" data-src="http://s9.51cto.com/wyfs02/M00/23/1C/wKioL1MyKrCDi39tAAAiPbfsd-Y863.jpg" alt="081028o2n5ebn8hdeh9e5l.png"></p><p>现在回到问题：如何求任意两点之间最短路径呢？通过之前的学习我们知道通过深度或广度优先搜索可以求出两点之间的最短路径。所以进行n2遍深度或广度优先搜索，即对每两个点都进行一次深度或广度优先搜索，便可以求得任意两点之间的最短路径。可是还有没有别的方法呢？</p><p>我们来想一想，根据我们以往的经验，如果要让任意两点（例如从顶点a点到顶点b）之间的路程变短，只能引入第三个点（顶点k），并通过这个顶点k中转即a-&gt;k-&gt;b，才可能缩短原来从顶点a点到顶点b的路程。那么这个中转的顶点k是1~n中的哪个点呢？甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即a-&gt;k1-&gt;k2b-&gt;或者a-&gt;k1-&gt;k2…-&gt;k-&gt;i…-&gt;b。比如上图中从4号城市到3号城市（4-&gt;3）的路程e[4][3]原本是12。如果只通过1号城市中转（4-&gt;1-&gt;3），路程将缩短为11（e[4][1]+e[1][3]&#x3D;5+6&#x3D;11）。其实1号城市到3号城市也可以通过2号城市中转，使得1号到3号城市的路程缩短为5（e[1][2]+e[2][3]&#x3D;2+3&#x3D;5）。所以如果同时经过1号和2号两个城市中转的话，从4号城市到3号城市的路程会进一步缩短为10。通过这个的例子，我们发现每个顶点都有可能使得另外两个顶点之间的路程变短。好，下面我们将这个问题一般化。</p><p>当任意两点之间不允许经过第三个点时，这些城市之间最短路程就是初始路程，如下。</p><p><img lazyload src="/images/loading.svg" data-src="http://s1.51cto.com/wyfs02/M01/23/1C/wKioL1MyKrDDfAv9AAAiPbfsd-Y211.jpg" alt="081029zdxxq919ttqt8tu8.png"></p><p>如现在只允许经过1号顶点，求任意两点之间的最短路程，应该如何求呢？只需判断e[i][1]+e[1][j]是否比e[i][j]要小即可。e[i][j]表示的是从i号顶点到j号顶点之间的路程。e[i][1]+e[1][j]表示的是从i号顶点先到1号顶点，再从1号顶点到j号顶点的路程之和。其中i是1<del>n循环，j也是1</del>n循环，代码实现如下。</p><ol><li>for(i&#x3D;1;i&lt;&#x3D;n;i++)</li><li>{</li><li>for(j&#x3D;1;j&lt;&#x3D;n;j++)</li><li>    {</li><li>if ( e[i][j] &gt; e[i][1]+e[1][j] )</li><li>e[i][j] &#x3D; e[i][1]+e[1][j];</li><li>    }</li><li>}</li></ol><p>在只允许经过1号顶点的情况下，任意两点之间的最短路程更新为：</p><p><img lazyload src="/images/loading.svg" data-src="http://s9.51cto.com/wyfs02/M02/23/1B/wKiom1MyKtixyd9aAAAimg6WCbM948.jpg" alt="081029itl7z7m4l9qqg56d.png"></p><p>通过上图我们发现：在只通过1号顶点中转的情况下，3号顶点到2号顶点（e[3][2]）、4号顶点到2号顶点（e[4][2]）以及4号顶点到3号顶点（e[4][3]）的路程都变短了。</p><p>接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短路程。如何做呢？我们需要在只允许经过1号顶点时任意两点的最短路程的结果下，再判断如果经过2号顶点是否可以使得i号顶点到j号顶点之间的路程变得更短。即判断e[i][2]+e[2][j]是否比e[i][j]要小，代码实现为如下。</p><ol><li>&#x2F;&#x2F;经过1号顶点</li><li>for(i&#x3D;1;i&lt;&#x3D;n;i++)</li><li>for(j&#x3D;1;j&lt;&#x3D;n;j++)</li><li>if (e[i][j] &gt; e[i][1]+e[1][j])  e[i][j]&#x3D;e[i][1]+e[1][j];</li><li>&#x2F;&#x2F;经过2号顶点</li><li>for(i&#x3D;1;i&lt;&#x3D;n;i++)</li><li>for(j&#x3D;1;j&lt;&#x3D;n;j++)</li><li>if (e[i][j] &gt; e[i][2]+e[2][j])  e[i][j]&#x3D;e[i][2]+e[2][j];</li></ol><p>在只允许经过1和2号顶点的情况下，任意两点之间的最短路程更新为：</p><p><img lazyload src="/images/loading.svg" data-src="http://s4.51cto.com/wyfs02/M00/23/1B/wKiom1MyKtjjpEHiAAAix7NGsrA796.jpg" alt="081029e7gjlaaul4zk7z4n.png"></p><p>通过上图得知，在相比只允许通过1号顶点进行中转的情况下，这里允许通过1和2号顶点进行中转，使得e[1][3]和e[4][3]的路程变得更短了。</p><p>同理，继续在只允许经过1、2和3号顶点进行中转的情况下，求任意两点之间的最短路程。任意两点之间的最短路程更新为：</p><p><img lazyload src="/images/loading.svg" data-src="http://s7.51cto.com/wyfs02/M01/23/1C/wKioL1MyKrGxpKlsAAAi4hPRt2k063.jpg" alt="081029pd747o8o87o07o7l.png"></p><p>最后允许通过所有顶点作为中转，任意两点之间最终的最短路程为：</p><p><img lazyload src="/images/loading.svg" data-src="http://s3.51cto.com/wyfs02/M02/23/1C/wKioL1MyKrHiJBcCAAAioTqzaQk771.jpg" alt="081030h7tmht7cs2h7qftu.png"></p><p>整个算法过程虽然说起来很麻烦，但是代码实现却非常简单，核心代码只有五行：</p><ol><li>for(k&#x3D;1;k&lt;&#x3D;n;k++)</li><li>for(i&#x3D;1;i&lt;&#x3D;n;i++)</li><li>for(j&#x3D;1;j&lt;&#x3D;n;j++)</li><li>if(e[i][j]&gt;e[i][k]+e[k][j])</li><li>   e[i][j]&#x3D;e[i][k]+e[k][j];</li></ol><p>这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。其实这是一种“动态规划”的思想，关于这个思想我们将在《啊哈！算法2——伟大思维闪耀时》在做详细的讨论。下面给出这个算法的完整代码：</p><ol><li><p>#include &lt;stdio.h&gt;   </p></li><li><p>int main()</p></li><li><p>{</p></li><li><p>int e[10][10],k,i,j,n,m,t1,t2,t3;</p></li><li><p>int inf&#x3D;99999999; &#x2F;&#x2F;用inf(infinity的缩写)存储一个我们认为的正无穷值</p></li><li><p>&#x2F;&#x2F;读入n和m，n表示顶点个数，m表示边的条数</p></li><li><p>    scanf(“%d %d”,&amp;n,&amp;m);</p></li><li><p>&#x2F;&#x2F;初始化</p></li><li><p>for(i&#x3D;1;i&lt;&#x3D;n;i++)</p></li><li><p>for(j&#x3D;1;j&lt;&#x3D;n;j++)</p></li><li><p>if(i&#x3D;&#x3D;j) e[i][j]&#x3D;0;</p></li><li><p>else e[i][j]&#x3D;inf;</p></li><li><p>&#x2F;&#x2F;读入边</p></li><li><p>for(i&#x3D;1;i&lt;&#x3D;m;i++)</p></li><li><p>    {</p></li><li><p> scanf(“%d %d %d”,&amp;t1,&amp;t2,&amp;t3);</p></li><li><p> e[t1][t2]&#x3D;t3;</p></li><li><p>    }</p></li><li><p>&#x2F;&#x2F;Floyd-Warshall算法核心语句</p></li><li><p>for(k&#x3D;1;k&lt;&#x3D;n;k++)</p></li><li><p>for(i&#x3D;1;i&lt;&#x3D;n;i++)</p></li><li><p>for(j&#x3D;1;j&lt;&#x3D;n;j++)</p></li><li><p>if(e[i][j]&gt;e[i][k]+e[k][j] )</p></li><li><p>      e[i][j]&#x3D;e[i][k]+e[k][j];</p></li><li><p>&#x2F;&#x2F;输出最终的结果</p></li><li><p>for(i&#x3D;1;i&lt;&#x3D;n;i++)</p></li><li><p>    {</p></li><li><p>for(j&#x3D;1;j&lt;&#x3D;n;j++)</p></li><li><p> {</p></li><li><p>     printf(“%10d”,e[i][j]);</p></li><li><p> }</p></li><li><p> printf(“\n”);</p></li><li><p>    }</p></li><li><p>return0;</p></li><li><p>}</p></li></ol><p>有一点需要注意的是：如何表示正无穷。我们通常将正无穷定义为99999999，因为这样即使两个正无穷相加，其和仍然不超过int类型的范围（C语言int类型可以存储的最大正整数是2147483647）。在实际应用中最好估计一下最短路径的上限，只需要设置比它大一点既可以。例如有100条边，每条边不超过100的话，只需将正无穷设置为10001即可。如果你认为正无穷和其它值相加得到一个大于正无穷的数是不被允许的话，我们只需在比较的时候加两个判断条件就可以了，请注意下面代码中带有下划线的语句。</p><ol><li>&#x2F;&#x2F;Floyd-Warshall算法核心语句</li><li>for(k&#x3D;1;k&lt;&#x3D;n;k++)</li><li>for(i&#x3D;1;i&lt;&#x3D;n;i++)</li><li>for(j&#x3D;1;j&lt;&#x3D;n;j++)</li><li>if(e[i][k]&lt;inf &amp;&amp; e[k][j]&lt;inf &amp;&amp; e[i][j]&gt;e[i][k]+e[k][j])</li><li>     e[i][j]&#x3D;e[i][k]+e[k][j];</li></ol><p>上面代码的输入数据样式为：</p><ol><li>48</li><li>122</li><li>136</li><li>144</li><li>233</li><li>317</li><li>341</li><li>415</li><li>4312</li></ol><p>第一行两个数为n和m，n表示顶点个数，m表示边的条数。</p><p>接下来m行，每一行有三个数t1、t2 和t3，表示顶点t1到顶点t2的路程是t3。</p><p>得到最终结果如下：</p><p><img lazyload src="/images/loading.svg" data-src="http://s1.51cto.com/wyfs02/M00/23/1B/wKiom1MyKtnRaui7AAAiIc6AlNg084.jpg" alt="081030is22w3mmnz3r33m3.png"></p><p>通过这种方法我们可以求出任意两个点之间最短路径。它的时间复杂度是O(N3)。令人很震撼的是它竟然只有五行代码，实现起来非常容易。正是因为它实现起来非常容易，如果时间复杂度要求不高，使用Floyd-Warshall来求指定两点之间的最短路或者指定一个点到其余各个顶点的最短路径也是可行的。当然也有更快的算法，请看下一节：Dijkstra算法。</p><p>另外需要注意的是：Floyd-Warshall算法不能解决带有“负权回路”（或者叫“负权环”）的图，因为带有“负权回路”的图没有最短路。例如下面这个图就不存在1号顶点到3号顶点的最短路径。因为1-&gt;2-&gt;3-&gt;1-&gt;2-&gt;3-&gt;…-&gt;1-&gt;2-&gt;3这样路径中，每绕一次1-&gt;-2&gt;3这样的环，最短路就会减少1，永远找不到最短路。其实如果一个图中带有“负权回路”那么这个图则没有最短路。</p><p><img lazyload src="/images/loading.svg" data-src="http://s9.51cto.com/wyfs02/M01/23/1B/wKiom1MyKtny9TMPAAAUSSCT5WA988.jpg" alt="081030elthvel6et6k886y.png"></p><p>此算法由Robert W. Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications of the ACM”上。同年Stephen Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。此外他还和J.W.J. Williams（威廉姆斯）于1964年共同发明了著名的堆排序算法HEAPSORT。堆排序算法我们将在第七章学习。Robert W．Floyd在1987年获得了图灵奖。</p><p>博客地址：<a class="link" target="_blank" rel="noopener" href="http://ahalei.blog.51cto.com/4767671/1383613">http://ahalei.blog.51cto.com/4767671/1383613<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h2 id="Huffman"><a href="#Huffman" class="headerlink" title="Huffman"></a>Huffman</h2><p>给定一个字符串，进行哈夫曼编码</p><pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct node&#123;
    int num;
    string data;
    node(int _num, string _data)&#123;
        num = _num; data = _data;
    &#125;
&#125;node;

bool operator&lt;(const node &amp;a, const node &amp;b)&#123;
     return a.num &gt; b.num;
&#125;


int main()&#123;
    int kase = 1;
    string line;
    while(getline(cin, line))&#123;
        int chr[30] = &#123;0&#125;;
        string answer[30];
        priority_queue&lt;node&gt; que;
        int len = line.length();
        for(int i = 0; i &lt; len; ++i)&#123;
            chr[line[i] - &#39;A&#39;]++;
        &#125;
        for(int i = 0; i &lt; 26; ++i)&#123;
            if(chr[i])&#123;
                string p = &quot;&quot;;
                que.push(node(chr[i], p + char(&#39;A&#39; + i)));
            &#125;
        &#125;

        int n = que.size() - 1;
        if(n &gt; 0)&#123;
            for(int i = 0; i &lt; n; ++i)&#123;
                node a = que.top(); que.pop();
                node b = que.top(); que.pop();
                for(int j = 0; j &lt; a.data.size(); ++j)&#123;
                    answer[a.data[j]-&#39;A&#39;] += &#39;0&#39;;
                &#125;
                for(int j = 0; j &lt; b.data.size(); ++j)&#123;
                    answer[b.data[j]-&#39;A&#39;] += &#39;1&#39;;
                &#125;
                que.push(node(a.num + b.num, a.data + b.data));
            &#125;
            cout &lt;&lt; &quot;Case #&quot; &lt;&lt; kase++ &lt;&lt; &quot;:&quot; &lt;&lt; endl;
            for(int i = 0; i &lt; 26; ++i)&#123;
                if(chr[i])&#123;
                    reverse(answer[i].begin(), answer[i].end());
                &#125;
            &#125;
            ///对answer字符串数组排序：相同chr的字符串按字典序排
            for(int i = 0; i &lt; 26; ++i)&#123;
                for(int j = i; j &lt; 26; ++j)&#123;
                    if(chr[i] == chr[j])&#123;
                        if(answer[j] &lt; answer[i])&#123;
                            swap(answer[i], answer[j]);
                        &#125;
                    &#125;

                &#125;
            &#125;
            ///以上对answer字符串数组排序：相同chr的字符串按按字典序排
            for(int i = 0; i &lt; 26; ++i)&#123;
                if(chr[i])&#123;
                    printf(&quot;%c: %s\n&quot;, i + &#39;A&#39;,answer[i].c_str());
                &#125;
            &#125;
            int sum = 0;
            for(int i = 0; i &lt; 26; ++i)&#123;
                sum += answer[i].size() * chr[i];
            &#125;
            cout &lt;&lt; sum;
            if(sum &lt; 50)&#123;
                cout &lt;&lt; &quot; &quot;;
                for(int i = 0; i &lt; len; ++i)&#123;
                    cout &lt;&lt; answer[line[i] - &#39;A&#39;];
                &#125;
            &#125;
        &#125; else if (n == 0)&#123;
            node fina = que.top();
            cout &lt;&lt; fina.data &lt;&lt; &quot;:&quot; &lt;&lt; 0 &lt;&lt; endl;
            cout &lt;&lt; len;
            if(len &lt; 50)&#123;
                cout &lt;&lt; &quot; &quot;;
                for(int i = 0; i &lt; len; ++i)&#123;
                    cout &lt;&lt; 0;
                &#125;
            &#125;
        &#125;
        cout &lt;&lt; endl;

    &#125;

&#125;
</code></pre><p>开心的wrong answer 正在查，<br>已查出错误，字典序保证方式出错 要保证为字典序不能后期排<br>因为要考虑同时保证最子权与父权的构建关系<br>不能生成后才排序编码</p><blockquote><p>而应是最简最直接思路<br>- <strong>排好序后进行编码</strong></p></blockquote><pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct node&#123;
    int num;
    string data;
    node(int _num, string _data)&#123;
        num = _num; data = _data;
    &#125;
    bool operator&lt;(const node &amp;b)const&#123;
         ///重点唯一改动
         if (num == b.num) return data[0] &gt; b.data[0];
         return num &gt; b.num;
    &#125;
&#125;node;



int main()&#123;
    int kase = 1;
    string line;
    while(getline(cin, line))&#123;
        int chr[30] = &#123;0&#125;;
        string answer[30];
        priority_queue&lt;node&gt; que;
        int len = line.length();
        for(int i = 0; i &lt; len; ++i)&#123;
            chr[line[i] - &#39;A&#39;]++;
        &#125;
        for(int i = 0; i &lt; 26; ++i)&#123;
            if(chr[i])&#123;
                string p = &quot;&quot;;
                que.push(node(chr[i], p + char(&#39;A&#39; + i)));
            &#125;
        &#125;
        int n = que.size() - 1;
        if(n &gt; 0)&#123;
            for(int i = 0; i &lt; n; ++i)&#123;
                node a = que.top(); que.pop();
                node b = que.top(); que.pop();
                for(int j = 0; j &lt; a.data.size(); ++j)&#123;
                    answer[a.data[j]-&#39;A&#39;] += &#39;0&#39;;
                &#125;
                for(int j = 0; j &lt; b.data.size(); ++j)&#123;
                    answer[b.data[j]-&#39;A&#39;] += &#39;1&#39;;
                &#125;
                que.push(node(a.num + b.num, a.data + b.data));
            &#125;
            cout &lt;&lt; &quot;Case #&quot; &lt;&lt; kase++ &lt;&lt; &quot;:&quot; &lt;&lt; endl;
            for(int i = 0; i &lt; 26; ++i)&#123;
                if(chr[i])&#123;
                    reverse(answer[i].begin(), answer[i].end());
                &#125;
            &#125;
            ///对answer字符串数组排序：相同chr的字符串按字典序排
            for(int i = 0; i &lt; 25; ++i)&#123;
                for(int j = 0; j &lt; 25 - i; ++j)&#123;
                    if(chr[j] &amp;&amp; chr[j+1])
                    if(chr[j] == chr[j+1])&#123;
                        if(answer[j] &gt; answer[j+1])&#123;
                            swap(answer[j+1], answer[j]);
                        &#125;
                    &#125;

                &#125;
            &#125;
            ///以上对answer字符串数组排序：相同chr的字符串按按字典序排
            for(int i = 0; i &lt; 26; ++i)&#123;
                if(chr[i])&#123;
                    printf(&quot;%c: %s\n&quot;, i + &#39;A&#39;,answer[i].c_str());
                &#125;
            &#125;
            int sum = 0;
            for(int i = 0; i &lt; 26; ++i)&#123;
                sum += answer[i].size() * chr[i];
            &#125;
            cout &lt;&lt; sum;
            if(sum &lt; 50)&#123;
                cout &lt;&lt; &quot; &quot;;
                for(int i = 0; i &lt; len; ++i)&#123;
                    cout &lt;&lt; answer[line[i] - &#39;A&#39;];
                &#125;
            &#125;
        &#125; else if (n == 0)&#123;
            node fina = que.top();
            cout &lt;&lt; &quot;Case #&quot; &lt;&lt; kase++ &lt;&lt; &quot;:&quot; &lt;&lt; endl;
            cout &lt;&lt; fina.data &lt;&lt; &quot;: &quot; &lt;&lt; 0 &lt;&lt; endl;
            cout &lt;&lt; len;
            if(len &lt; 50)&#123;
                cout &lt;&lt; &quot; &quot;;
                for(int i = 0; i &lt; len; ++i)&#123;
                    cout &lt;&lt; 0;
                &#125;
            &#125;
        &#125;
        cout &lt;&lt; endl;

    &#125;

&#125;
</code></pre><p><img lazyload src="/images/loading.svg" data-src="http://img.blog.csdn.net/20161102133253964" alt="这里写图片描述"></p><h2 id="Power-of-Two"><a href="#Power-of-Two" class="headerlink" title="Power of Two"></a>Power of Two</h2><p>Given an integer, write a function to determine if it is a power of two.</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; !(n&amp;(n<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Explain: 100 &amp; 011 &#x3D; 0</p><p>Try think about power of 4: <code>return num &gt; 0 &amp;&amp; (num &amp; (num - 1)) == 0 &amp;&amp; (num - 1) % 3 == 0;</code></p><blockquote><p>(4^n - 1) % 3 &#x3D;&#x3D; 0<br>proof:<br>(1) 4^n - 1 &#x3D; (2^n + 1) * (2^n - 1)<br>(2) among any 3 consecutive numbers, there must be one that is a multiple of 3<br>among (2^n-1), (2^n), (2^n+1), one of them must be a multiple of 3, and (2^n) cannot be the one, therefore either (2^n-1) or (2^n+1) must be a multiple of 3, and 4^n-1 must be a multiple of 3 as well.</p></blockquote><h2 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h2><p><a class="link" target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/discuss/25057/3-4-short-lines-Integer-Newton-Every-Language/24092">https://leetcode.com/problems/sqrtx/discuss/25057/3-4-short-lines-Integer-Newton-Every-Language/24092<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> r = x;</span><br><span class="line"><span class="keyword">while</span> (r*r &gt; x)</span><br><span class="line">    r = (r + x/r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://assets.leetcode.com/static_assets/discuss/uploads/files/1502465638921-95f6f6f0-a1b8-4f19-919d-1a0b53e18aac-image.png" alt="answer"></p><h2 id="Redo-or-Undo"><a href="#Redo-or-Undo" class="headerlink" title="Redo or Undo"></a>Redo or Undo</h2><blockquote><p>撤销模拟程序 编写程序模拟word中的“重做Redo”“撤销Undo”两个按钮。即键盘输入一段文字（不能含#，e.g., I as Tom whether he will go to Beijingh）之后输入“#U”（“U”代表Undo）则撤销最后一个输入的字符(“h”)，在输出位置重新输出一遍新撤销后的串。这时可以再继续输入。当然，也可以输入“#R”恢复刚才删除的输入h。每有一次#R都要输出一下新的结果。当然，可以同时连续输入多个#U或多个#R。比如，输入#U#U#R#U#U#U#R#R。</p></blockquote><ul><li>Input<ul><li>第一行为一个数字T，代表一共有T组测试样例，每组测试样例包含以下内容：<br>每行包含一串字母（包含空格，不超过100个字符）。<br>开始第一个字母不能为“#”，即第一个字母必须要敲入文字。<br>“#R”表示重做。<br>“#U”表示撤销。<br>“##”表示本次测试样例结束。</li></ul></li><li>Ouput<ul><li>每输入一次重做，都要输出操作之后的文字</li></ul></li></ul><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int cases;</span><br><span class="line">cin &gt;&gt; cases;   getchar();</span><br><span class="line">for(int kase = 1; kase &lt;= cases; ++kase)&#123;</span><br><span class="line"></span><br><span class="line">        stack&lt;char&gt; cc;</span><br><span class="line">        string oper = &quot;&quot;, opert;</span><br><span class="line"></span><br><span class="line">        while(getline(cin, opert) &amp;&amp; opert != &quot;##&quot;)&#123;</span><br><span class="line">            if(opert[0] == &#x27;#&#x27;)&#123;</span><br><span class="line">                if(opert[1] == &#x27;U&#x27;)&#123;</span><br><span class="line">                    int num = oper.size() - 1;</span><br><span class="line">                    if(num &gt;= 0)&#123;</span><br><span class="line">                        cc.push(oper[num]);</span><br><span class="line">                        //cout &lt;&lt; oper[num] &lt;&lt; &quot;*-*&quot; &lt;&lt; cc.size() &lt;&lt; endl;</span><br><span class="line">                        oper.resize(num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(opert[1] == &#x27;R&#x27;)&#123;</span><br><span class="line">                    if(!cc.empty())&#123;</span><br><span class="line">                        char c = cc.top();</span><br><span class="line">                        oper += c;</span><br><span class="line">                        cc.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout &lt;&lt; oper  &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                    oper += opert;</span><br><span class="line">                    while(!cc.empty()) cc.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="求后缀表达式"><a href="#求后缀表达式" class="headerlink" title="求后缀表达式"></a>求后缀表达式</h2><blockquote><p>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p></blockquote><pre><code>//中缀表达式转后缀表达式的方法：
//1.遇到操作数：直接输出（添加到后缀表达式中）
//2.栈为空时，遇到运算符，直接入栈
//3.遇到左括号：将其入栈
//4.遇到右括号：执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出。
//5.遇到其他运算符：加减乘除：弹出所有优先级大于或者等于该运算符的栈顶元素，然后将该运算符入栈
//6.最终将栈中的元素依次出栈，输出。
//fork from http://www.cnblogs.com/mygmh/archive/2012/10/06/2713362.html
</code></pre><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    </span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; sym;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sym.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>));</span><br><span class="line">    sym.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>));</span><br><span class="line">    sym.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>));</span><br><span class="line">    sym.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInt</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> b-a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> b*a;</span><br><span class="line">    <span class="keyword">return</span> b/a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ss;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> kase = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; ss)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase++ &lt;&lt; <span class="string">&quot;:&quot;</span>  &lt;&lt; endl;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; last;</span><br><span class="line">        stack&lt;<span class="type">double</span>&gt; answer;</span><br><span class="line">        <span class="type">int</span> qsize = ss.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; qsize; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isInt</span>(ss[i]))&#123; <span class="comment">/// num is the true num</span></span><br><span class="line">                <span class="type">double</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">isInt</span>(ss[i]))&#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + ss[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> point = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(ss[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    ++i;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">isInt</span>(ss[i]))&#123;</span><br><span class="line">                        num = num * <span class="number">10</span> + ss[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        ++i;    ++point;</span><br><span class="line">                    &#125;</span><br><span class="line">                    --i;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; point; ++j)&#123;</span><br><span class="line">                        num /= <span class="number">10.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> --i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%.*lf &quot;</span>, point, num);</span><br><span class="line">                answer.<span class="built_in">push</span>(num);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (last.<span class="built_in">empty</span>() || ss[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                last.<span class="built_in">push</span>(ss[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ss[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(last.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">///calculate the num</span></span><br><span class="line">                        <span class="type">double</span> a = answer.<span class="built_in">top</span>(); answer.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="type">double</span> b = answer.<span class="built_in">top</span>(); answer.<span class="built_in">pop</span>();</span><br><span class="line">                        answer.<span class="built_in">push</span>(<span class="built_in">calc</span>(a,b, last.<span class="built_in">top</span>()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">///epichar</span></span><br><span class="line">                    cout &lt;&lt; last.<span class="built_in">top</span>();</span><br><span class="line">                    last.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                last.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!last.<span class="built_in">empty</span>() &amp;&amp; sym[ss[i]] &lt;= sym[last.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                    <span class="type">double</span> a = answer.<span class="built_in">top</span>(); answer.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">double</span> b = answer.<span class="built_in">top</span>(); answer.<span class="built_in">pop</span>();</span><br><span class="line">                    answer.<span class="built_in">push</span>(<span class="built_in">calc</span>(a,b, last.<span class="built_in">top</span>()));</span><br><span class="line"></span><br><span class="line">                    cout &lt;&lt; last.<span class="built_in">top</span>();</span><br><span class="line">                    last.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                last.<span class="built_in">push</span>(ss[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!last.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">double</span> a = answer.<span class="built_in">top</span>(); answer.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">double</span> b = answer.<span class="built_in">top</span>(); answer.<span class="built_in">pop</span>();</span><br><span class="line">            answer.<span class="built_in">push</span>(<span class="built_in">calc</span>(a,b, last.<span class="built_in">top</span>()));</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; last.<span class="built_in">top</span>();</span><br><span class="line">            last.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The answer is &quot;</span>;</span><br><span class="line">        <span class="type">double</span> ans = answer.<span class="built_in">top</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%g&quot;</span>,ans);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt;endl &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">    Language: C++</span></span><br><span class="line"><span class="comment">    Result: Accepted</span></span><br><span class="line"><span class="comment">    Time:1668 ms</span></span><br><span class="line"><span class="comment">    Memory:1296 kb</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h2 id="How-to-calc-the-next-array"><a href="#How-to-calc-the-next-array" class="headerlink" title="How to calc the next array."></a>How to calc the next array.</h2><ol><li><p>Calc the max length of suffix and prefix as follows:</p><table><thead><tr><th>string</th><th>a</th><th>b</th><th>a</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>a</th></tr></thead><tbody><tr><td>length</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>0</td><td>1</td><td>2</td><td>3</td></tr><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>As you can see, the next array is the <strong>suffix equals prefix length array</strong> move on one step and init the first values as -1.</p></li></ol><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span>  </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">      <span class="type">int</span> k = <span class="number">-1</span>,  = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span> (j &lt; (p.length - <span class="number">1</span>)) &#123;  </span><br><span class="line">          <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">          <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) &#123;  </span><br><span class="line">              ++j, ++k, next[j] = k;  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              k = next[k];  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure></div><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><h2 id="在n个城市之间建设网络，只需保证连通即可，求最经济的架设方法。"><a href="#在n个城市之间建设网络，只需保证连通即可，求最经济的架设方法。" class="headerlink" title="在n个城市之间建设网络，只需保证连通即可，求最经济的架设方法。"></a>在n个城市之间建设网络，只需保证连通即可，求最经济的架设方法。</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul><li>有多组输入数据。每组第一行输入三个整数n、m、c（1&lt;&#x3D;n,m,c&lt;&#x3D;100000），分别代表城市数量，可建道路数量和单位长度道路修建费用。接下来m行每行三个整数u、v(1&lt;&#x3D;u,v&lt;&#x3D;n)、d(1&lt;&#x3D;d&lt;&#x3D;100000)。代表可建道路的起点城市、终点城市和长度。</li></ul><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><ul><li>每组数据输出一行，输出数据组数和使所有城市连通的最小费用，无法全部连通输出-1。</li></ul><h4 id="Kruskal算法的步骤："><a href="#Kruskal算法的步骤：" class="headerlink" title="Kruskal算法的步骤："></a><strong>Kruskal算法的步骤：</strong></h4><p>1.对所有边进行从小到大的排序。 2.每次选一条边（最小的边），如果如果形成环，就不加入(u,v)中，否则加入。那么加入的(u,v)一定是最佳的。</p><h4 id="并查集解决，略微优化：路径压缩"><a href="#并查集解决，略微优化：路径压缩" class="headerlink" title="并查集解决，略微优化：路径压缩"></a><strong>并查集解决，略微优化：路径压缩</strong></h4><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Kruskal算法的步骤：</span></span><br><span class="line"><span class="comment">///1.对所有边进行从小到大的排序。</span></span><br><span class="line"><span class="comment">///2.每次选一条边（最小的边），如果如果形成环，就不加入(u,v)中，否则加入。</span></span><br><span class="line"><span class="comment">///那么加入的(u,v)一定是最佳的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///构成环的条件就是u，v已经连通，则不能添加</span></span><br><span class="line"><span class="comment">///关于这一点可用并查集查掌门解决</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> beg;</span><br><span class="line">    <span class="type">int</span> las;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">Node node[<span class="number">10200</span>];</span><br><span class="line"><span class="type">int</span> prev[<span class="number">10200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.len &lt; b.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">finds</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = x;</span><br><span class="line">    <span class="keyword">while</span>(prev[r] != r)&#123;</span><br><span class="line">        r = prev[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">finds</span>(x), fy = <span class="built_in">finds</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        prev[fx] = fy;<span class="comment">///fx != fy,即无共同顶点，不构成三点环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cases;  cin &gt;&gt; cases;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kase = <span class="number">1</span>; kase &lt;= cases; ++kase)&#123;</span><br><span class="line">        <span class="type">int</span> n, m, c, sum = <span class="number">0</span>, tree = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            prev[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> u, v, d;</span><br><span class="line">            cin &gt;&gt; node[i].beg &gt;&gt; node[i].las &gt;&gt; node[i].len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(node, node + m, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">join</span>(node[i].beg, node[i].las))&#123;</span><br><span class="line">               sum += node[i].len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev[i] == i)&#123;</span><br><span class="line">                tree++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; kase &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; sum*c;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; 傻逼的爆了一堆超时，二次弱逼式优化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> beg;</span><br><span class="line">    <span class="type">int</span> las;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;node[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prevs[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.len &lt; b.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">finds</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = x;</span><br><span class="line">    <span class="keyword">while</span>(prevs[r] != r)&#123;</span><br><span class="line">        r = prevs[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    <span class="keyword">while</span>(t != r)&#123;</span><br><span class="line">        <span class="type">int</span> tf = prevs[t];</span><br><span class="line">        prevs[t] = r;</span><br><span class="line">        t = tf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">finds</span>(x), fy = <span class="built_in">finds</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        prevs[fx] = fy;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cases;  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cases);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> kase = <span class="number">1</span>; kase &lt;= cases; ++kase)&#123;</span><br><span class="line">        <span class="type">int</span> n, m, c, sides = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">                prevs[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;node[i].beg, &amp;node[i].las, &amp;node[i].len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(node, node + m, cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">join</span>(node[i].beg, node[i].las))&#123;</span><br><span class="line">               sum += node[i].len;</span><br><span class="line">               sides++;</span><br><span class="line">               <span class="keyword">if</span>(sides == n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, kase);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sides == n<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum*c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> Algo tips</li><li><strong>Author:</strong> ReZero</li><li><strong>Created at :</strong> 2020-08-10 10:35:00</li><li><strong>Updated at :</strong> 2025-04-15 23:03:26</li><li><strong>Link:</strong> https://rezeros.github.io/2020/08/10/algo-tips/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/Algorithm/">#Algorithm</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/Math/">#Math</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/Tips/">#Tips</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2020/08/12/java-lock/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">Java Lock</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2020/08/09/tcp/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">TCP</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="giscus-container"></div><script data-swup-reload-script defer>async function loadGiscus(){const t={src:"https://giscus.app/client.js","data-repo":"rezeros/rezeros.github.io","data-repo-id":"MDEwOlJlcG9zaXRvcnkxNjk3MzU3NzA=","data-category":"Announcements","data-category-id":"DIC_kwDOCh32Ws4Co2GO","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"1","data-theme":"preferred_color_scheme","data-lang":"en","data-input-position":"bottom","data-loading":"not-lazy",crossorigin:"anonymous",async:!0},a=document.createElement("script");for(const e in t)a.setAttribute(e,t[e]);document.getElementById("giscus-container").appendChild(a)}{let t=setTimeout(()=>{loadGiscus(),clearTimeout(t)},1e3)}</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">Algo tips</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Search"><span class="nav-text">Binary Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RSA-basic"><span class="nav-text">RSA-basic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-1"><span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-%EF%BC%88%E8%BD%AC%EF%BC%89"><span class="nav-text">并查集 （转）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eight-queens"><span class="nav-text">Eight queens</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Floyd"><span class="nav-text">Floyd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A4%E7%AE%97%E6%B3%95%E7%94%B1Robert-W-Floyd%EF%BC%88%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%EF%BC%89%E4%BA%8E1962%E5%B9%B4%E5%8F%91%E8%A1%A8%E5%9C%A8%E2%80%9CCommunications-of-the-ACM%E2%80%9D%E4%B8%8A%E3%80%82%E5%90%8C%E5%B9%B4Stephen-Warshall%EF%BC%88%E5%8F%B2%E8%92%82%E8%8A%AC%C2%B7%E6%B2%83%E8%88%8D%E5%B0%94%EF%BC%89%E4%B9%9F%E7%8B%AC%E7%AB%8B%E5%8F%91%E8%A1%A8%E4%BA%86%E8%BF%99%E4%B8%AA%E7%AE%97%E6%B3%95%E3%80%82Robert-W%EF%BC%8EFloyd%E8%BF%99%E4%B8%AA%E7%89%9B%E4%BA%BA%E6%98%AF%E6%9C%B5%E5%A5%87%E8%91%A9%EF%BC%8C%E4%BB%96%E5%8E%9F%E6%9C%AC%E5%9C%A8%E8%8A%9D%E5%8A%A0%E5%93%A5%E5%A4%A7%E5%AD%A6%E8%AF%BB%E7%9A%84%E6%96%87%E5%AD%A6%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%BD%93%E6%97%B6%E7%BE%8E%E5%9B%BD%E7%BB%8F%E6%B5%8E%E4%B8%8D%E5%A4%AA%E6%99%AF%E6%B0%94%EF%BC%8C%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%AF%94%E8%BE%83%E5%9B%B0%E9%9A%BE%EF%BC%8C%E6%97%A0%E5%A5%88%E4%B9%8B%E4%B8%8B%E5%88%B0%E8%A5%BF%E5%B1%8B%E7%94%B5%E6%B0%94%E5%85%AC%E5%8F%B8%E5%BD%93%E4%BA%86%E4%B8%80%E5%90%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E5%91%98%EF%BC%8C%E5%9C%A8IBM650%E6%9C%BA%E6%88%BF%E5%80%BC%E5%A4%9C%E7%8F%AD%EF%BC%8C%E5%B9%B6%E7%94%B1%E6%AD%A4%E5%BC%80%E5%A7%8B%E4%BA%86%E4%BB%96%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%9F%E6%B6%AF%E3%80%82"><span class="nav-text">此算法由Robert W. Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications of the ACM”上。同年Stephen Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Huffman"><span class="nav-text">Huffman</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Power-of-Two"><span class="nav-text">Power of Two</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sqrt-x"><span class="nav-text">Sqrt(x)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redo-or-Undo"><span class="nav-text">Redo or Undo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">求后缀表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP"><span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-calc-the-next-array"><span class="nav-text">How to calc the next array.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kruskal"><span class="nav-text">Kruskal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8n%E4%B8%AA%E5%9F%8E%E5%B8%82%E4%B9%8B%E9%97%B4%E5%BB%BA%E8%AE%BE%E7%BD%91%E7%BB%9C%EF%BC%8C%E5%8F%AA%E9%9C%80%E4%BF%9D%E8%AF%81%E8%BF%9E%E9%80%9A%E5%8D%B3%E5%8F%AF%EF%BC%8C%E6%B1%82%E6%9C%80%E7%BB%8F%E6%B5%8E%E7%9A%84%E6%9E%B6%E8%AE%BE%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-text">在n个城市之间建设网络，只需保证连通即可，求最经济的架设方法。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#input"><span class="nav-text">input</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#output"><span class="nav-text">output</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">ReZero</a><p class="post-count space-x-0.5"><span>60 posts in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div></main><script src="/js/build/libs/Swup.min.js"></script><script src="/js/build/libs/SwupSlideTheme.min.js"></script><script src="/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="/js/build/libs/SwupProgressPlugin.min.js"></script><script src="/js/build/libs/SwupScrollPlugin.min.js"></script><script src="/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/build/tools/imageViewer.js" type="module"></script><script src="/js/build/utils.js" type="module"></script><script src="/js/build/main.js" type="module"></script><script src="/js/build/layouts/navbarShrink.js" type="module"></script><script src="/js/build/tools/scrollTopBottom.js" type="module"></script><script src="/js/build/tools/lightDarkSwitch.js" type="module"></script><script src="/js/build/layouts/categoryList.js" type="module"></script><script src="/js/build/tools/codeBlock.js" type="module"></script><script src="/js/build/layouts/lazyload.js" type="module"></script><script src="/js/build/tools/runtime.js"></script><script src="/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/build/libs/Typed.min.js"></script><script src="/js/build/plugins/typed.js" type="module"></script><script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script><script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script><script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script><script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script></body></html>