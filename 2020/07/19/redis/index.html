<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="ReZero"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="https://rezeros.github.io/2020/07/19/redis/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Before that, think more."><meta property="og:type" content="article"><meta property="og:title" content="(转) Redis 基础知识笔记记录"><meta property="og:url" content="https://rezeros.github.io/2020/07/19/redis/index.html"><meta property="og:site_name" content="ReZero"><meta property="og:description" content="Before that, think more."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://rezeros.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2020-07-19T22:00:00.000Z"><meta property="article:modified_time" content="2025-04-15T23:03:26.503Z"><meta property="article:author" content="ReZero"><meta property="article:tag" content="Redis"><meta property="article:tag" content="Middleware"><meta property="article:tag" content="Cache"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://rezeros.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/redefine-favicon.svg"><title>(转) Redis 基础知识笔记记录 | ReZero&#39;s blog</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/build/tailwind.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><script src="/js/build/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"rezeros.github.io",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:"Advance ruthlessly—whatever the cost!"},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Before that, think more."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"Before that, think more.",subtitle:{text:[],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Categories:{path:"/categories/",icon:"fa-solid fa-folder"},Tags:{path:"/tags/",icon:"fa-solid fa-tags"}},search:{enable:!1,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:null},article_date_format:"auto",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/8/17 11:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">Advance ruthlessly—whatever the cost!</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">ReZero&#39;s blog</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/categories/"><i class="fa-solid fa-folder fa-fw"></i> CATEGORIES</a></li><li class="navbar-item"><a href="/tags/"><i class="fa-solid fa-tags fa-fw"></i> TAGS</a></li></ul></div><div class="mobile"><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/"><span>CATEGORIES </span><i class="fa-solid fa-folder fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/tags/"><span>TAGS </span><i class="fa-solid fa-tags fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">138</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">21</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">60</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">(转) Redis 基础知识笔记记录</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/redefine-avatar.svg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">ReZero</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv4</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2020-07-19 22:00</span> <span class="mobile">2020-07-19 22:00</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-04-15 23:03:26</span> <span class="mobile">2025-04-15 23:03:26</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/Redis/">Redis</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/Redis/">Redis</a>&nbsp;</li><li>| <a href="/tags/Middleware/">Middleware</a>&nbsp;</li><li>| <a href="/tags/Cache/">Cache</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><p>文章笔记参考链接来自作者 敖丙</p><p>开源项目：<a class="link" target="_blank" rel="noopener" href="https://github.com/AobingJava/JavaFamily">https://github.com/AobingJava/JavaFamily<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><p>以及 Redis 设计与实现</p><p>以及 钱大的 Redis 深度历险</p><h2 id="Redis-常见应用"><a href="#Redis-常见应用" class="headerlink" title="Redis 常见应用"></a>Redis 常见应用</h2><ul><li>记录帖子的点赞数、评论数和点击数 (hash)。</li><li>记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。</li><li>记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。</li><li>记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。</li><li>缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (hash)。</li><li>记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。</li><li>如果帖子 ID 是整数自增的，可以使用 Redis 来分配帖子 ID(计数器)。</li><li>收藏集和帖子之间的关系 (zset)。</li><li>记录热榜帖子 ID 列表，总热榜和分类热榜 (zset)。</li><li>缓存用户行为历史，进行恶意行为过滤 (zset,hash)。</li><li>数据推送去重Bloom filter pv，uv统计</li></ul><h3 id="小菜"><a href="#小菜" class="headerlink" title="小菜"></a>小菜</h3><h4 id="delay-queue"><a href="#delay-queue" class="headerlink" title="delay queue"></a>delay queue</h4><p>Redis 可以做单消费组的消息对列，但没有 ack 保证的原因意味着可靠性也没有保证。</p><blockquote><p>redis 队列可能出现空队列时 pop 的空轮询，这种情况下 一般采用sleep(1000) 让其他线程获取可执行的机会</p></blockquote><h4 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h4><p>签到，用户日活</p><p>可以设 key 为前缀:用户id:年月， <code>setbit sign:123:1909 0 1</code> 代表用户 123 19年9月 第 1（就是0的时候）天签到 bitcount来统计签到天数</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>Page visit，简单的 incrby 就可<br>User visit 就无法简单处理，如果每个页面一个 set 就很爆炸<br>HyperLoglog的 pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用户 ID 塞进去就是，pfcount 和 scard 用法是一样的，直接获取计数值。</p><h3 id="bloom-过滤器"><a href="#bloom-过滤器" class="headerlink" title="bloom 过滤器"></a>bloom 过滤器</h3><p>bf.add bf.exists 比如新闻推荐，url爬取等的去重操作</p><p>布隆过滤器的initial_size估计的过大，会浪费存储空间，估计的过小，就会影响准确率，用户在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避免实际元素可能会意外高出估计值很多。</p><p>布隆过滤器的error_rate越小，需要的存储空间就越大，对于不需要过于精确的场合，error_rate设置稍大一点也无伤大雅。比如在新闻去重上而言，误判率高一点只会让小部分文章不能让合适的人看到，文章的整体阅读量不会因为这点误判率就带来巨大的改变。</p><p>大致说下原理：</p><p>初始化 n 个元素长度的的数组，提供 k 个hash 函数，从数组的角度来看，当有元素hash对数组的某个索引命中时，那么这个地方就置为1，注意的是数组的位置只有第一次设置为1后后面的设置就不再起效</p><p>这样当我们对 给定值应用了 k 次 hash后发现全部落在数组值为 1 的地方，那么我们就判定这个元素在数组中是存在的。</p><p>tips: 可以看出来这东西并不绝对，有一定的误差，至于怎么把这个误差减到最少，需要了解下相关的推论。</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>基本五个：</p><p><code>String、Hash、List、Set、SortedSet</code></p><p>然后还有：<code>HyperLogLog、Geo、Pub/Sub</code></p><p>以及 Redis Module，比如：<code>BloomFilter，RedisSearch，Redis-ML</code></p><ol><li><p>String: 常见缓存，共享session等，强烈不建议复杂结构做 jsonToString 之类的操作。</p></li><li><p>hash， map一般不常用，难见场景</p></li><li><p>list：常用来存储列表之类的数据，比如lrange 命令，读取某个闭区间内的元素，可以基于 List 实现下拉那种分页查询，再就是阻塞队列了。</p></li><li><p>set，一般用来运算并交差集之类的，比如取两个人的共同好友之类的</p></li><li><p>zset：根据 score 作为权重的排序</p></li></ol><hr><p>String： 类似一个ArrayList&lt;Byte|Char&gt;, 加了长度限制字段，目的是尽可能高效且不浪费利用空间并且防范缓冲区溢出等问题。</p><hr><p>list：类似 linked list，双向链表, 可实现队列，栈效果</p><hr><p>hash：类似 hashMap 仅通过数组加链表解决hash冲突，实际上字典结构的内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 渐进式搬迁 。</p><p>渐进式 rehash：就是持有两个hashtable，查地时候去两个里面查，这样避免一次性大扩容单线程的 redis 顶不住。</p><p>扩容条件：正常情况下，当 hash表中 元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是 原数组大小的 2倍。不过如果 Redis正在做 bgsave(持久化命令)，为了减少内存也得过多分离，Redis尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。<br>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。</p><hr><p>集合 set：Redis 的集合相当于 Java 语言中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value 都是一个值 NULL。</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">     <span class="comment">//编码方式</span></span><br><span class="line">     <span class="type">uint32_t</span> encoding;</span><br><span class="line">     <span class="comment">//集合包含的元素数量</span></span><br><span class="line">     <span class="type">uint32_t</span> length;</span><br><span class="line">     <span class="comment">//保存元素的数组</span></span><br><span class="line">     <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol><li><p>intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合中。因此使用时需同时满足元素皆是整数且数量不超过max-intset-entries</p></li><li><p>hashtable 编码的集合对象使用 字典作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值则全部设置为 null。这里可以类比Java集合中HashSet<br>集合的实现，HashSet 集合是由 HashMap 来实现的，集合中的元素就是 HashMap 的key，而 HashMap 的值都设为 null。</p></li></ol><hr><p>zset：跳表<br>基本结构类似于一个多层二分链表，但是为了避免插入引起的 O(N) 效率问题，采用了这样的方案：不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是 为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是 3<br>，那么就把它链入到第 1 层到第 3 层这三层链表中。</p><hr><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li><p>大量的key设置相同的过期时间不可取，尽量分散随机防止同时失效时涌入大量的请求造成缓存雪崩。或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</p></li><li><p>scan 取代keys 带来的影响：Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key<br>列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。不过，增量式迭代命令也不是没有缺点的：举个例子，使用 SMEMBERS命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。</p></li><li><p>异步队列，rpush生产消息，lpop消费消息，如果不sleep的话blpop可以阻塞消息的到来。使用pub&#x2F;sub主题订阅者模式，可以实现 1:N 的消息队列，但该模式在消费者下线的情况下，生产的消息会丢失。</p></li><li><p>延时队列的实现：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p></li><li><p>持久化：RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。其实就类似与全表与日志恢复的补偿措施。</p></li></ol><div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">RDB: </span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">他会生成多个数据文件，每个数据文件分别都代表了某一时刻Redis</span><br><span class="line">里面的数据，这种方式，有没有觉得很适合做冷备，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。</span><br><span class="line"></span><br><span class="line">RDB对Redis的性能影响非常小，是因为在同步数据的时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比AOF来的快。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">RDB都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。AOF则最多丢一秒的数据，数据完整性上高下立判。</span><br><span class="line"></span><br><span class="line">还有就是RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候fork了一个子进程去生成一个大快照，哦豁，出大问题。</span><br><span class="line"></span><br><span class="line">AOF</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">上面提到了，RDB五分钟一次生成快照，但是AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据。</span><br><span class="line"></span><br><span class="line">AOF在对日志文件进行操作的时候是以append-only的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。</span><br><span class="line"></span><br><span class="line">AOF的日志是通过一个叫非常可读的方式记录的，这样的特性就适合做灾难性数据误删除的紧急恢复了，比如公司的实习生通过flushall清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份AOF日志文件，把最后一条flushall命令删了就完事了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">一样的数据，AOF文件比RDB还要大。</span><br><span class="line"></span><br><span class="line">AOF开启后，Redis支持写的QPS会比RDB支持写的要低，他不是每秒都要去异步刷新一次日志嘛fsync，当然即使这样性能还是很高，我记得ElasticSearch也是这样的，异步刷新缓存区的数据去持久化，为啥这么做呢，不直接来一条怼一条呢，那我会告诉你这样性能可能低到没办法用的，大家可以思考下为啥哟。</span><br><span class="line"></span><br><span class="line">综上：出事第一时间用RDB恢复，然后AOF做数据补全</span><br></pre></td></tr></table></figure></div><ol start="6"><li><p>sync：持久化时的断点可能造成影响，所以需要定时 sync，可以 1 s 执行一次，这样最多丢失 1s 的数据。</p></li><li><p>RDB 原理： fork(Linux 子进程的那个 fork)&amp; copy on write</p></li><li><p><strong>pipeline</strong> : 可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline<br>批次指令的数目。</p></li><li><p><strong>同步机制</strong> : Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB<br>镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</p></li><li><p>集群：</p><ul><li>Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</li><li>Redis Cluster 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</li></ul></li><li><p>缓存穿透：构建不存在于缓存和数据库的 key 发起攻击。解决方案是用参数校验比如分页大小不要没个限制之类的，或者 bloom 过滤，不存在就设置空对象到缓存去，同时给这个key一个较短的过期时间。</p></li><li><p>缓存击穿：极度热点的 key 失效的瞬间。 解决方案：不要过期或者加个互斥锁。</p></li></ol><hr><p>事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。</p><p>事中：本地 ehcache 缓存 + Hystrix 限流+降级，避免MySQL被打死。</p><p>事后：Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p><hr><h3 id="集群实例"><a href="#集群实例" class="headerlink" title="集群实例"></a>集群实例</h3><ol><li><p>我们用到了集群的部署方式也就是Redis cluster，并且是主从同步读写分离，类似Mysql的主从同步，Redis cluster 支撑 N 个 Redis master node，每个master node都可以挂载多个 slave node。<br>这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p></li><li><p>数据持久化，持久化的话是Redis高可用中比较重要的一个环节，因为Redis数据在内存的特性，持久化必须得有，我了解到的持久化是有两种方式的。</p><ul><li>RDB：RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。</li><li>AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog。</li><li>两种方式都可以把Redis内存中的数据持久化到磁盘上，然后再将这些数据备份到别的地方去，RDB更适合做冷备，AOF<br>更适合做热备，比如我杭州的某电商公司有这两个数据，我备份一份到我杭州的节点，再备份一个到上海的，就算发生无法避免的自然灾害，也不会两个地方都一起挂吧，这灾备也就是异地容灾，地球毁灭他没办法。<blockquote><p>tip：两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的。</p></blockquote></li></ul></li><li><p>哨兵组件的功能</p><ul><li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul></li><li><p>读写分离的数据同步方案：启动一台slave 的时候，他会发送一个psync命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成RDB快照，还会把新的写请求都缓存在内存中，RDB文件生成后，master会将这个RDB发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。</p></li><li><p>Linked hash map 实现 LRU 缓存，accessOrder 的实现就是 move node to the last</p></li><li><p>关于 key 的失效： 定期删除和惰性删除，如果不能满足这两种那就只有缓存淘汰了。淘汰的策略有这些：<a class="link" target="_blank" rel="noopener" href="https://redis.io/topics/lru-cache">Cache invalidation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></li></ol><h3 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h3><ol><li><p>多个系统同时操作（并发）Redis带来的数据问题：</p><ol><li><p>某个时刻，多个系统实例都去更新某个 key。可以基于 Zookeeper 实现分布式锁。每个系统通过 Zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 Key，别人都不允许读和写。</p></li><li><p>你要写入缓存的数据，都是从 MySQL 里查出来的，都得写入 MySQL 中，写入 MySQL 中的时候必须保存一个时间戳，从 MySQL 查出来的时候，时间戳也查出来。</p></li><li><p>每次要写之前，先判断一下当前这个 Value 的时间戳是否比缓存里的 Value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。 感觉有点像cas</p></li></ol></li><li><p>缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，这个时候一般是取舍，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。串行的问题不用说自然就是效率问题，拉垮性能。</p></li></ol><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。<br>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 Socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h3 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h3><h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><ol><li><p>秒杀也建个微服务，对应的秒杀库</p></li><li><p>高可用： Redis集群，主从同步、读写分离，我们还搞点哨兵，开启持久化</p></li><li><p>Nginx 负载均衡打 tomcat 群</p></li><li><p>资源静态化，能放 CDN 就放</p></li><li><p>Button loading or disabled</p></li><li><p>后端限流</p><ul><li>阿里的Sentinel、Hystrix</li><li>库存预热：加载到 redis 中，配合 lua</li></ul></li><li><p>限流&amp;降级&amp;熔断&amp;隔离。限流，顶不住就挡一部分出去但是不能说不行，降级，降级了还是被打挂了，熔断，至少不要影响别的系统，隔离，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。</p></li><li><p>削峰填谷： 上 mq</p></li></ol><img lazyload src="/images/loading.svg" data-src="/2020/07/19/redis/%E7%A7%92%E6%9D%80%E6%9E%B6%E6%9E%84.png" title="秒杀架构"><h4 id="全栈"><a href="#全栈" class="headerlink" title="全栈"></a>全栈</h4><ol><li><p>Node js</p><ul><li><p>Master-Worker 模式，Node 提供了 child_process 模块，或者说 cluster 模块也行，可以利用 child_process 模块直接创建子进程。fork的目的是为了利用 cpu 资源</p></li><li><p>句柄传递去掉主进程代理，Egg.js 将它们放到了一个单独的进程上去执行，这个进程就叫 Agent Worker，简称 Agent，专门用来处理一些公共事务</p></li></ul></li></ol><h3 id="Redis-命令学习"><a href="#Redis-命令学习" class="headerlink" title="Redis 命令学习"></a>Redis 命令学习</h3><ol><li><p>大key检查： <code>redis-cli --bigkeys -i 0.01</code></p></li><li><p>模块采样，查看高频访问 <code>redis-cli --host 192.168.x.x --port 6379 monitor</code></p></li><li><p>时延查询 <code>redis-cli --host 192.168.x.x --port 6379 --latency</code>不仅是物理网络的时延，还和当前的 Redis 主线程是否忙碌有关。如果你发现 Unix 的 ping 指令时延很小，而 Redis 的时延很大，那说明 Redis 服务器在执行指令时有微弱卡顿。</p></li><li><p>将远程的 Redis 实例备份到本地机器，远程服务器会执行一次bgsave操作，然后将 rdb 文件传输到客户端。<code>./redis-cli --host 192.168.x.x --port 6379 --rdb ./user.rdb</code></p></li><li><p>观察主从服务器之间都同步了那些数据，可以使用 redis-cli 模拟从库 <code>./redis-cli --host 192.168.x.x --port 6379 --slave</code> 从库连上主库的第一件事是全量同步，所以看到上面的指令卡顿这很正常，待首次全量同步完成后，就会输出增量的 aof 日志。</p></li><li><p>更新缓存时建议直接删缓存，如果没有那么从数据库取</p><ul><li>如果先走数据库，后操作缓存（CacheAsidePattern）存在缓存删除失败的情况，处理方案：在高并发下表现优异，在原子性被破坏时表现不如意<ul><li>将需要删除的key发送到消息队列中</li><li>自己消费消息，获得需要删除的key</li><li>不断重试删除操作，直到成功</li></ul></li><li>先删除缓存，再更新数据库：在高并发下表现不如意，在原子性被破坏时表现优异<ul><li>将操作积压到队列里进行串行化的操作，避免并发带来的问题</li></ul></li></ul></li></ol><h3 id="Redis-实现消息队列"><a href="#Redis-实现消息队列" class="headerlink" title="Redis 实现消息队列"></a>Redis 实现消息队列</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Callback for processing received objects through Redis.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> message message must not be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pattern pattern matching the channel (if specified) - can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="meta">@Nullable</span> <span class="type">byte</span>[] pattern)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class encapsulating a Redis message body and its properties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Costin Leau</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Christoph Strobl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Message</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the body (or the payload) of the message.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> message body. Never &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">byte</span>[] getBody();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the channel associated with the message.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> message channel. Never &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">byte</span>[] getChannel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisTemplate.convertAndSend(chanenl, message)</span><br></pre></td></tr></table></figure></div><ol><li><p>redis队列监听器的监听机制是：使用一个线程监听队列，队列有未消费的消息则取出消息并生成一个新的线程来消费消息。如果你还记得，我开头说的是由于redis单线程特性，因此我们用它来做消息队列，但是如果监听器每次接受一个消息就生成新的线程来消费信息的话，这样就完全没有使用到redis的单线程特性，同时还会产生线程安全问题。</p></li><li><p>一个通道只有一个消费者的解决办法：最简单的办法莫过于为onMessage<br>()方法加锁，这样简单粗暴却很有用，不过这种方式无法控制队列监听的速率，且无限制的创造线程最终会导致系统资源被占光。解决方案：RedisMessageListenerContainer类中有一个方法setTaskExecutor<br>(Executor taskExecutor)可以为监听容器配置线程池。配置线程池以后，所有的线程都会由该线程池产生，由此，我们可以通过调节线程池来控制队列监听的速率。</p></li><li><p>上锁样例</p></li></ol><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisLockRegistry <span class="title function_">redisLockRegistry</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisLockRegistry</span>(factory, <span class="string">&quot;lock-name&quot;</span>, timeForRelease);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisListener</span> implement MessageListener&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowrite</span></span><br><span class="line">    <span class="keyword">private</span> RedisLockRegistry redisLockRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(RedisListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message,<span class="type">byte</span>[] pattern)</span>&#123;</span><br><span class="line">        Lock lock=redisLockRegistry.obtain(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock(); <span class="comment">//上锁</span></span><br><span class="line">            LOGGER.debug(<span class="string">&quot;从消息通道=&#123;&#125;监听到消息&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(pattern));</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;从消息通道=&#123;&#125;监听到消息&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(message.getChannel()));</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;元消息=&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">            <span class="comment">// 新建一个用于反序列化的对象，注意这里的对象要和前面配置的一样</span></span><br><span class="line">            <span class="comment">// 因为我前面设置的默认序列化方式为GenericJackson2JsonRedisSerializer</span></span><br><span class="line">            <span class="comment">// 所以这里的实现方式为GenericJackson2JsonRedisSerializer</span></span><br><span class="line">            RedisSerializer serializer=<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;反序列化后的消息=&#123;&#125;&quot;</span>,serializer.deserialize(message.getBody()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="常见锁"><a href="#常见锁" class="headerlink" title="常见锁"></a>常见锁</h4><ol><li>基于 MySQL 中的锁：MySQL 本身有自带的悲观锁 for update 关键字，也可以自己实现悲观&#x2F;乐观锁来达到目的；但是要</li><li>基于 Zookeeper 有序节点：Zookeeper 允许临时创建有序的子节点，这样客户端获取节点列表时，就能够当前子节点列表中的序号判断是否能够获得锁；</li><li>基于 Redis 的单线程：由于 Redis 是单线程，所以命令会以串行的方式执行，并且本身提供了像 SETNX(set if not exists) 这样的指令，本身具有互斥性；</li></ol><h4 id="Redis-锁的释放"><a href="#Redis-锁的释放" class="headerlink" title="Redis 锁的释放"></a>Redis 锁的释放</h4><p>设置时间怕临界区还没结束就放了，所以不要长任务。同时因为这个A超时释放了那期间就会有别的B捡起锁，这样可能A执行完了事务把B的锁给释放了，所以还有种方案就是值设置为随机数，这样删key的时候先看看是不是自己的那个锁，这个方案需要Lua<br>的支持来保证 check 和 delete 为一个原子操作。</p><h4 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h4><p>服务 A 申请到一把锁之后，如果作为主机的 Redis 宕机了，那么 服务 B 在申请锁的时候就会从从机那里获取到这把锁，为了解决这个问题，Redis 作者提出了一种 RedLock 红锁 的算法 (Redission 同 Jedis)：</p><h4 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>官方文档也在 SETNX 文档中提到了这样一种思路：把 SETNX 对应 key 的 value 设置为 &lt;current Unix time + lock timeout + 1&gt;，这样在其他客户端访问时就能够自己判断是否能够获取下一个 value 为上述格式的锁了。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ol><li><p>redis 库</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span> </span><br><span class="line">    <span class="type">int</span> id;         <span class="comment">// 数据库ID标识</span></span><br><span class="line">    dict *dict;     <span class="comment">// 键空间，存放着所有的键值对              </span></span><br><span class="line">    dict *expires;  <span class="comment">// 过期哈希表，保存着键的过期时间                          </span></span><br><span class="line">    dict *watched_keys; <span class="comment">// 被watch命令监控的key和相应client    </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;  <span class="comment">// 数据库内所有键的平均TTL（生存时间）     </span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></div></li><li><p>RDB: 根据修改次数和时间来决定是否调用 bgsave 生成 RDB 文件。RDB不会存储过期键，创建时会进行相应的检查。</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">   <span class="comment">// 修改计数器</span></span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">   <span class="type">time_t</span> lastsave;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 参数的配置</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div></li><li><p>AOF: 以 redis 序列化协议的方式记录写命令，为了压缩指令集的大小，比如将多个push合为一个push，<code>BGREWRITEAOF</code> 提供类似该命令效果的重写功能配置，重写不依赖于现有的aof<br>文件，而是基于现有库分析拿到重写的指令集数据。类似bgsave fork 子进程重写时会出现不一致的问题，是通过加个临时缓冲区暂存后执行命令解决的。混合模式下 AOF指的是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志</p><ol><li>命令追加：命令写入aof_buf缓冲区</li><li>文件写入：调用flushAppendOnlyFile函数，考虑是否要将aof_buf缓冲区写入AOF文件中</li><li>文件同步：考虑是否将内存缓冲区的数据真正写入到硬盘</li></ol></li><li><p>RDB 执行优先级低于 AOF，此外关于持久化相关的配置：</p><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis持久化，两种方式</span><br><span class="line">1、rdb快照方式</span><br><span class="line">2、aof日志方式</span><br><span class="line"></span><br><span class="line">----------rdb快照------------</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir /var/rdb/</span><br><span class="line"></span><br><span class="line">-----------Aof的配置-----------</span><br><span class="line">appendonly no # 是否打开 aof日志功能</span><br><span class="line"></span><br><span class="line">appendfsync always #每一个命令都立即同步到aof，安全速度慢</span><br><span class="line">appendfsync everysec</span><br><span class="line">appendfsync no 写入工作交给操作系统，由操作系统判断缓冲区大小，统一写入到aof  同步频率低，速度快</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite yes 正在导出rdb快照的时候不要写aof</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb </span><br></pre></td></tr></table></figure></div></li><li><p>内核缓冲区成功写入认为已经写入，但到磁盘缓存后再到落盘这中间两步仍然无法避免停电的问题，而Linux 默认30 秒将缓冲区做真正的写提交从而落盘，除此之外 <code>fsync</code> 命令也有相应的效果。</p></li></ol><h3 id="Redis-stream"><a href="#Redis-stream" class="headerlink" title="Redis stream"></a>Redis stream</h3><ol><li><p>消息用不同的 ID 来区分</p><ul><li>Consumer Group：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 XREAD命令进行独立消费，也可以多个消费者同时加入一个消费者组进行 组内消费。同一个消费者组内的消费者共享所有的 Stream 信息，同一条消息只会有一个消费者消费到，这样就可以应用在分布式的应用场景中来保证消息的唯一性。</li><li>last_delivered_id：用来表示消费者组消费在 Stream 上 消费位置 的游标信息。每个消费者组都有一个 Stream 内 唯一的名称，消费者组不会自动创建，需要使用 XGROUP CREATE指令来显式创建，并且需要指定从哪一个消息 ID开始消费，用来初始化 last_delivered_id 这个变量。</li><li>pending_ids：每个消费者内部都有的一个状态变量，用来表示 已经 被客户端 获取，但是 还没有 ack的消息。记录的目的是为了保证客户端至少消费了消息一次，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 PEL (Pending Entries List)。</li></ul></li><li><p>Stream 消息太多怎么办？</p></li></ol><p>设置限定消息长度，对老消息进行淘汰</p><ol start="3"><li>PEL 丢失问题：在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL中的消息 ID列表。不过此时 xreadgroup 的起始消息 ID 不能为参数 &gt; ，而必须是任意有效的消息 ID，一般将参数设为 0-0，表示读取所有的 PEL 消息以及自 last_delivered_id 之后的新消息。</li></ol><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>[集群参考](<a class="link" target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUyMTg0NDA2Ng==&mid=2247484047&idx=1&sn=9b8a62d204ed82805a997878500eef16&chksm">https://mp.weixin.qq.com/s?__biz=MzUyMTg0NDA2Ng==&amp;mid=2247484047&amp;idx=1&amp;sn=9b8a62d204ed82805a997878500eef16&amp;chksm<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>&#x3D;f9d5a682cea22f94a10b3e1d302a2b98079a0c4e72049283b3e9a34e541b4a4aa79bc0a0970d&amp;scene&#x3D;21#wechat_redirect)</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ol><li><p>指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 主节点(master)，后者称为 从节点(slave)。且数据的复制是 单向 的，只能由主节点到从节点。Redis主从复制支持 主从同步 和 从从同步 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p></li><li><p>三个阶段：准备阶段-数据同步阶段-命令传播阶段。</p></li></ol><img lazyload src="/images/loading.svg" data-src="/2020/07/19/redis/master-slave.png" title="主从复制"><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><ol><li>主服务器的选择<ul><li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 淘汰。</li><li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 淘汰。</li><li>在经历了以上两轮淘汰之后 剩下来的从服务器中， 我们选出 复制偏移量（replication offset<br>）最大 的那个(越大说明数据越比较新) 从服务器 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 带有最小运行 ID 的那个从服务器成为新的主服务器。</li></ul></li></ol><h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><p>维护一个hash 环，服务器作为Hash 环上的节点，求 hash 时会落到节点附近，这个时候按顺时针找到第一个节点即为存放节点。按顺时针会有一个问题就是如果环上的点较为集中会使得hash<br>全部打在顺向的的同一个节点上，因此引入了虚拟节点的概念，让节点本身承担虚拟节点，这样就会得到一个均匀的环，当然虚拟的节点最终会打在实际的服务节点上。</p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> (转) Redis 基础知识笔记记录</li><li><strong>Author:</strong> ReZero</li><li><strong>Created at :</strong> 2020-07-19 22:00:00</li><li><strong>Updated at :</strong> 2025-04-15 23:03:26</li><li><strong>Link:</strong> https://rezeros.github.io/2020/07/19/redis/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/Redis/">#Redis</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/Middleware/">#Middleware</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/Cache/">#Cache</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2020/07/29/mysql-transaction/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">(转)Mysql Transaction</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2020/07/18/site-architechture/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">Site Architecture</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="giscus-container"></div><script data-swup-reload-script defer>async function loadGiscus(){const t={src:"https://giscus.app/client.js","data-repo":"rezeros/rezeros.github.io","data-repo-id":"MDEwOlJlcG9zaXRvcnkxNjk3MzU3NzA=","data-category":"Announcements","data-category-id":"DIC_kwDOCh32Ws4Co2GO","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"1","data-theme":"preferred_color_scheme","data-lang":"en","data-input-position":"bottom","data-loading":"not-lazy",crossorigin:"anonymous",async:!0},a=document.createElement("script");for(const e in t)a.setAttribute(e,t[e]);document.getElementById("giscus-container").appendChild(a)}{let t=setTimeout(()=>{loadGiscus(),clearTimeout(t)},1e3)}</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">(转) Redis 基础知识笔记记录</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8"><span class="nav-text">Redis 常见应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E8%8F%9C"><span class="nav-text">小菜</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HyperLogLog"><span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bloom-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">bloom 过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">Redis 数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%AE%9E%E4%BE%8B"><span class="nav-text">集群实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-text">分布式问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-text">秒杀系统设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0"><span class="nav-text">Redis 命令学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">Redis 实现消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-stream"><span class="nav-text">Redis stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4"><span class="nav-text">集群</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">ReZero</a><p class="post-count space-x-0.5"><span>60 posts in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div></main><script src="/js/build/libs/Swup.min.js"></script><script src="/js/build/libs/SwupSlideTheme.min.js"></script><script src="/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="/js/build/libs/SwupProgressPlugin.min.js"></script><script src="/js/build/libs/SwupScrollPlugin.min.js"></script><script src="/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/build/tools/imageViewer.js" type="module"></script><script src="/js/build/utils.js" type="module"></script><script src="/js/build/main.js" type="module"></script><script src="/js/build/layouts/navbarShrink.js" type="module"></script><script src="/js/build/tools/scrollTopBottom.js" type="module"></script><script src="/js/build/tools/lightDarkSwitch.js" type="module"></script><script src="/js/build/layouts/categoryList.js" type="module"></script><script src="/js/build/tools/codeBlock.js" type="module"></script><script src="/js/build/layouts/lazyload.js" type="module"></script><script src="/js/build/tools/runtime.js"></script><script src="/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/build/libs/Typed.min.js"></script><script src="/js/build/plugins/typed.js" type="module"></script><script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script><script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script><script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script><script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script></body></html>